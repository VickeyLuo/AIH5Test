<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¦å…‹å¤§æˆ˜</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            font-size: 10px;
        }
        
        body {
            font-family: 'Noto Sans SC', 'Inter', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #1e3c72 100%);
            background-size: 400% 400%;
            animation: gradientShift 10s ease infinite;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .game-container {
            backdrop-filter: blur(10px);
            background: rgba(17, 24, 39, 0.9);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }
        
        #gameCanvas {
            border: 2px solid #374151;
            border-radius: 8px;
            background: #0f172a;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.2s;
            user-select: none;
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="text-white min-h-screen flex items-center justify-center p-4">
    <div class="game-container p-8 flex flex-col lg:flex-row gap-8 items-start">
        <!-- æ¸¸æˆåŒºåŸŸ -->
        <div class="flex flex-col items-center">
            <h1 class="text-3xl font-bold mb-4 text-blue-400">å¦å…‹å¤§æˆ˜</h1>
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <!-- æ§åˆ¶æŒ‰é’® -->
            <div class="flex gap-4 mt-4">
                <button id="startBtn" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded-lg font-medium transition-colors">
                    å¼€å§‹æ¸¸æˆ
                </button>
                <button id="pauseBtn" class="bg-yellow-600 hover:bg-yellow-700 px-6 py-3 rounded-lg font-medium transition-colors" disabled>
                    æš‚åœ
                </button>
                <button id="resetBtn" class="bg-red-600 hover:bg-red-700 px-6 py-3 rounded-lg font-medium transition-colors">
                    é‡ç½®
                </button>
            </div>
            
            <!-- ç§»åŠ¨ç«¯æ§åˆ¶ -->
            <div class="lg:hidden mt-6">
                <div class="grid grid-cols-3 gap-2 mb-4">
                    <div></div>
                    <button id="upBtn" class="control-btn bg-gray-600 hover:bg-gray-700">â†‘</button>
                    <div></div>
                    <button id="leftBtn" class="control-btn bg-gray-600 hover:bg-gray-700">â†</button>
                    <button id="fireBtn" class="control-btn bg-red-600 hover:bg-red-700">ğŸ”¥</button>
                    <button id="rightBtn" class="control-btn bg-gray-600 hover:bg-gray-700">â†’</button>
                    <div></div>
                    <button id="downBtn" class="control-btn bg-gray-600 hover:bg-gray-700">â†“</button>
                    <div></div>
                </div>
            </div>
        </div>
        
        <!-- ä¿¡æ¯é¢æ¿ -->
        <div class="bg-gray-800 p-6 rounded-lg min-w-[250px]">
            <div class="space-y-4">
                <div>
                    <span class="text-gray-400">ç”Ÿå‘½å€¼:</span>
                    <span id="lives" class="text-xl font-bold text-red-400 ml-2">3</span>
                </div>
                <div>
                    <span class="text-gray-400">å¾—åˆ†:</span>
                    <span id="score" class="text-xl font-bold text-blue-400 ml-2">0</span>
                </div>
                <div>
                    <span class="text-gray-400">å…³å¡:</span>
                    <span id="level" class="text-xl font-bold text-green-400 ml-2">1</span>
                </div>
                <div>
                    <span class="text-gray-400">æ•Œæ–¹å¦å…‹:</span>
                    <span id="enemies" class="text-xl font-bold text-yellow-400 ml-2">5</span>
                </div>
            </div>
            
            <!-- è¡€æ¡æ˜¾ç¤º -->
            <div class="mt-4 space-y-3">
                <div>
                    <div class="flex justify-between text-sm text-gray-400 mb-1">
                        <span>ç©å®¶è¡€é‡</span>
                        <span id="playerHealthText">100/100</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3">
                        <div id="playerHealthBar" class="bg-green-500 h-3 rounded-full transition-all duration-300" style="width: 100%"></div>
                    </div>
                </div>
                <div>
                    <div class="flex justify-between text-sm text-gray-400 mb-1">
                        <span>åŸºåœ°è¡€é‡</span>
                        <span id="baseHealthText">100/100</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-3">
                        <div id="baseHealthBar" class="bg-yellow-500 h-3 rounded-full transition-all duration-300" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            
            <div class="mt-6 text-sm text-gray-400">
                <h4 class="font-semibold mb-2 text-white">æ“ä½œè¯´æ˜:</h4>
                <div class="space-y-1">
                    <div>WASD / æ–¹å‘é”®: ç§»åŠ¨</div>
                    <div>Ké”®: å¼€ç«</div>
                    <div>Pé”®: æš‚åœ/ç»§ç»­</div>
                </div>
            </div>
            
            <div class="mt-6 text-sm text-gray-400">
                <h4 class="font-semibold mb-2 text-white">æ¸¸æˆè§„åˆ™:</h4>
                <div class="space-y-1">
                    <div>â€¢ æ¶ˆç­æ‰€æœ‰æ•Œæ–¹å¦å…‹</div>
                    <div>â€¢ ä¿æŠ¤ä½ çš„åŸºåœ°</div>
                    <div>â€¢ åˆ©ç”¨éšœç¢ç‰©æ©æŠ¤</div>
                    <div>â€¢ æ”¶é›†é“å…·å¢å¼ºèƒ½åŠ›</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        class TankBattle {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameRunning = false;
                this.gameLoop = null;
                
                // æ¸¸æˆçŠ¶æ€
                this.lives = 3;
                this.score = 0;
                this.level = 1;
                this.enemyCount = 5;
                
                // æ¸¸æˆå¯¹è±¡
                this.player = null;
                this.enemies = [];
                this.bullets = [];
                this.walls = [];
                this.powerUps = [];
                this.base = null;
                this.baseWalls = [];
                
                // è¾“å…¥çŠ¶æ€
                this.keys = {};
                
                this.initGame();
                this.bindEvents();
            }
            
            initGame() {
                // åˆ›å»ºç©å®¶å¦å…‹
                this.player = {
                    x: 100,
                    y: 500,
                    width: 40,
                    height: 40,
                    direction: 0, // 0:ä¸Š, 1:å³, 2:ä¸‹, 3:å·¦
                    speed: 3,
                    health: 100,
                    maxHealth: 100,
                    lastShot: 0,
                    shotCooldown: 300
                };
                
                // åˆ›å»ºæ•Œæ–¹å¦å…‹
                this.enemies = [];
                for (let i = 0; i < this.enemyCount; i++) {
                    let x, y;
                    let attempts = 0;
                    do {
                        x = Math.random() * (this.canvas.width - 40);
                        y = Math.random() * (this.canvas.height / 2 - 40); // åªåœ¨ä¸ŠåŠéƒ¨åˆ†ç”Ÿæˆ
                        attempts++;
                    } while (attempts < 50 && (
                        this.checkWallCollision(x, y, 40, 40) ||
                        this.checkTankCollision({x, y, width: 40, height: 40}, x, y)
                    ));
                    
                    this.enemies.push({
                        x: x,
                        y: y,
                        width: 40,
                        height: 40,
                        direction: Math.floor(Math.random() * 4),
                        speed: 1 + Math.random(),
                        health: 50,
                        lastShot: 0,
                        shotCooldown: 1000 + Math.random() * 1000,
                        lastDirectionChange: 0,
                        directionChangeCooldown: 1000 + Math.random() * 1000,
                        stuckCounter: 0,
                        lastPosition: {x: x, y: y},
                        preferredDirection: -1,
                        directionStability: 0
                    });
                }
                
                // åˆ›å»ºç©å®¶åŸºåœ°
                this.base = {
                    x: 360,
                    y: 540,
                    width: 80,
                    height: 40,
                    health: 100,
                    maxHealth: 100
                };
                
                // åˆ›å»ºåŸºåœ°é˜²æŠ¤å¢™
                this.baseWalls = [
                    {x: 340, y: 520, width: 20, height: 20, health: 1, maxHealth: 1, holes: []}, // å·¦ä¸Š
                    {x: 360, y: 520, width: 20, height: 20, health: 1, maxHealth: 1, holes: []}, // ä¸Šå·¦
                    {x: 380, y: 520, width: 20, height: 20, health: 1, maxHealth: 1, holes: []}, // ä¸Šä¸­
                    {x: 400, y: 520, width: 20, height: 20, health: 1, maxHealth: 1, holes: []}, // ä¸Šå³
                    {x: 420, y: 520, width: 20, height: 20, health: 1, maxHealth: 1, holes: []}, // å³ä¸Š
                    {x: 340, y: 540, width: 20, height: 20, health: 1, maxHealth: 1, holes: []}, // å·¦ä¸­
                    {x: 420, y: 540, width: 20, height: 20, health: 1, maxHealth: 1, holes: []}, // å³ä¸­
                    {x: 340, y: 560, width: 20, height: 20, health: 1, maxHealth: 1, holes: []}, // å·¦ä¸‹
                    {x: 420, y: 560, width: 20, height: 20, health: 1, maxHealth: 1, holes: []}  // å³ä¸‹
                ];
                
                // åˆ›å»ºå¢™å£
                this.walls = [
                    {x: 200, y: 200, width: 60, height: 20},
                    {x: 400, y: 150, width: 20, height: 100},
                    {x: 600, y: 300, width: 80, height: 20},
                    {x: 300, y: 400, width: 20, height: 80},
                    {x: 500, y: 450, width: 100, height: 20},
                    {x: 150, y: 300, width: 20, height: 60},
                    {x: 650, y: 150, width: 60, height: 20}
                ];
                
                this.bullets = [];
                this.powerUps = [];
                this.explosions = []; // æ·»åŠ çˆ†ç‚¸æ•ˆæœæ•°ç»„
                
                this.updateDisplay();
            }
            
            update() {
                if (!this.gameRunning) return;
                
                // æ›´æ–°ç©å®¶
                this.updatePlayer();
                
                // æ›´æ–°æ•Œæ–¹å¦å…‹
                this.updateEnemies();
                
                // æ›´æ–°å­å¼¹
                this.updateBullets();
                
                // æ›´æ–°çˆ†ç‚¸æ•ˆæœ
                this.updateExplosions();
                
                // æ£€æŸ¥ç¢°æ’
                this.checkCollisions();
                
                // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
                this.checkGameEnd();
                
                // æ›´æ–°æ˜¾ç¤ºä¿¡æ¯
                this.updateDisplay();
            }
            
            updatePlayer() {
                const player = this.player;
                let moved = false;
                
                // ç§»åŠ¨æ§åˆ¶
                if (this.keys['w'] || this.keys['ArrowUp']) {
                    player.direction = 0;
                    const newY = player.y - player.speed;
                    if (player.y > 0 && !this.checkWallCollision(player.x, newY, player.width, player.height) &&
                        !this.checkTankCollision(player, player.x, newY)) {
                        player.y = newY;
                        moved = true;
                    }
                }
                if (this.keys['s'] || this.keys['ArrowDown']) {
                    player.direction = 2;
                    const newY = player.y + player.speed;
                    if (player.y < this.canvas.height - player.height && !this.checkWallCollision(player.x, newY, player.width, player.height) &&
                        !this.checkTankCollision(player, player.x, newY)) {
                        player.y = newY;
                        moved = true;
                    }
                }
                if (this.keys['a'] || this.keys['ArrowLeft']) {
                    player.direction = 3;
                    const newX = player.x - player.speed;
                    if (player.x > 0 && !this.checkWallCollision(newX, player.y, player.width, player.height) &&
                        !this.checkTankCollision(player, newX, player.y)) {
                        player.x = newX;
                        moved = true;
                    }
                }
                if (this.keys['d'] || this.keys['ArrowRight']) {
                    player.direction = 1;
                    const newX = player.x + player.speed;
                    if (player.x < this.canvas.width - player.width && !this.checkWallCollision(newX, player.y, player.width, player.height) &&
                        !this.checkTankCollision(player, newX, player.y)) {
                        player.x = newX;
                        moved = true;
                    }
                }
                
                // å°„å‡»æ§åˆ¶
                if ((this.keys['k'] || this.keys['K']) && Date.now() - player.lastShot > player.shotCooldown) {
                    this.playerShoot();
                }
            }
            
            updateEnemies() {
                const now = Date.now();
                
                this.enemies.forEach(enemy => {
                    // æ£€æµ‹æ˜¯å¦å¡ä½
                    if (Math.abs(enemy.x - enemy.lastPosition.x) < 1 && Math.abs(enemy.y - enemy.lastPosition.y) < 1) {
                        enemy.stuckCounter++;
                        if (enemy.stuckCounter > 30) { // å¦‚æœ30å¸§éƒ½æ²¡æœ‰æ˜æ˜¾ç§»åŠ¨
                            enemy.direction = Math.floor(Math.random() * 4);
                            enemy.stuckCounter = 0;
                            enemy.lastDirectionChange = now;
                        }
                    } else {
                        enemy.stuckCounter = 0;
                        enemy.lastPosition.x = enemy.x;
                        enemy.lastPosition.y = enemy.y;
                    }
                    
                    // AIç§»åŠ¨
                    if (now - enemy.lastDirectionChange > enemy.directionChangeCooldown) {
                        enemy.direction = Math.floor(Math.random() * 4);
                        enemy.lastDirectionChange = now;
                    }
                    
                    let newX = enemy.x;
                    let newY = enemy.y;
                    
                    switch (enemy.direction) {
                        case 0: newY -= enemy.speed; break;
                        case 1: newX += enemy.speed; break;
                        case 2: newY += enemy.speed; break;
                        case 3: newX -= enemy.speed; break;
                    }
                    
                    // è¾¹ç•Œæ£€æŸ¥å’Œç¢°æ’æ£€æµ‹
                    if (newX >= 0 && newX <= this.canvas.width - enemy.width &&
                        newY >= 0 && newY <= this.canvas.height - enemy.height &&
                        !this.checkWallCollision(newX, newY, enemy.width, enemy.height) &&
                        !this.checkTankCollision(enemy, newX, newY)) {
                        enemy.x = newX;
                        enemy.y = newY;
                    } else {
                        // æ™ºèƒ½é€‰æ‹©å¯è¡Œæ–¹å‘ï¼Œé¿å…åŸåœ°æ‰“è½¬
                        const validDirections = [];
                        for (let dir = 0; dir < 4; dir++) {
                            let testX = enemy.x;
                            let testY = enemy.y;
                            
                            switch (dir) {
                                case 0: testY -= enemy.speed; break;
                                case 1: testX += enemy.speed; break;
                                case 2: testY += enemy.speed; break;
                                case 3: testX -= enemy.speed; break;
                            }
                            
                            if (testX >= 0 && testX <= this.canvas.width - enemy.width &&
                                testY >= 0 && testY <= this.canvas.height - enemy.height &&
                                !this.checkWallCollision(testX, testY, enemy.width, enemy.height) &&
                                !this.checkTankCollision(enemy, testX, testY)) {
                                validDirections.push(dir);
                            }
                        }
                        
                        if (validDirections.length > 0) {
                            // ä¼˜å…ˆé€‰æ‹©å½“å‰æ–¹å‘æˆ–é¦–é€‰æ–¹å‘ï¼Œé¿å…é¢‘ç¹è½¬å‘
                            let chosenDirection;
                            if (validDirections.includes(enemy.direction)) {
                                chosenDirection = enemy.direction; // ä¿æŒå½“å‰æ–¹å‘
                            } else if (enemy.preferredDirection !== -1 && validDirections.includes(enemy.preferredDirection)) {
                                chosenDirection = enemy.preferredDirection; // é€‰æ‹©é¦–é€‰æ–¹å‘
                            } else {
                                chosenDirection = validDirections[Math.floor(Math.random() * validDirections.length)];
                                enemy.preferredDirection = chosenDirection; // è®¾ç½®æ–°çš„é¦–é€‰æ–¹å‘
                            }
                            enemy.direction = chosenDirection;
                        } else {
                            // å¦‚æœæ²¡æœ‰å¯è¡Œæ–¹å‘ï¼Œå°è¯•åé€€
                            enemy.direction = (enemy.direction + 2) % 4;
                            enemy.preferredDirection = enemy.direction;
                        }
                        enemy.lastDirectionChange = now;
                    }
                    
                    // AIä¼˜å…ˆæ”»å‡»åŸºåœ° - æ”¹è¿›æ–¹å‘ç¨³å®šæ€§
                    if (Math.random() < 0.5) {
                        const dx = this.base.x + this.base.width / 2 - (enemy.x + enemy.width / 2);
                        const dy = this.base.y + this.base.height / 2 - (enemy.y + enemy.height / 2);
                        
                        let targetDirection;
                        // å¢åŠ é˜ˆå€¼é¿å…é¢‘ç¹åˆ‡æ¢æ–¹å‘
                        const threshold = 20;
                        if (Math.abs(dx) > Math.abs(dy) + threshold) {
                            targetDirection = dx > 0 ? 1 : 3; // å³æˆ–å·¦
                        } else if (Math.abs(dy) > Math.abs(dx) + threshold) {
                            targetDirection = dy > 0 ? 2 : 0; // ä¸‹æˆ–ä¸Š
                        } else {
                            // è·ç¦»ç›¸è¿‘æ—¶ï¼Œä¿æŒå½“å‰æ–¹å‘æˆ–é€‰æ‹©é¦–é€‰æ–¹å‘
                            if (enemy.preferredDirection !== -1) {
                                targetDirection = enemy.preferredDirection;
                            } else {
                                targetDirection = enemy.direction;
                            }
                        }
                        
                        // æ£€æŸ¥ç›®æ ‡æ–¹å‘æ˜¯å¦å¯è¡Œ
                        let testX = enemy.x;
                        let testY = enemy.y;
                        
                        switch (targetDirection) {
                            case 0: testY -= enemy.speed; break;
                            case 1: testX += enemy.speed; break;
                            case 2: testY += enemy.speed; break;
                            case 3: testX -= enemy.speed; break;
                        }
                        
                        if (testX >= 0 && testX <= this.canvas.width - enemy.width &&
                            testY >= 0 && testY <= this.canvas.height - enemy.height &&
                            !this.checkWallCollision(testX, testY, enemy.width, enemy.height) &&
                            !this.checkTankCollision(enemy, testX, testY)) {
                            
                            // å¦‚æœæ–¹å‘æ”¹å˜ï¼Œå¢åŠ ç¨³å®šæ€§è®¡æ•°
                            if (enemy.direction !== targetDirection) {
                                enemy.directionStability++;
                                if (enemy.directionStability > 3) { // éœ€è¦è¿ç»­3æ¬¡æ‰æ”¹å˜æ–¹å‘
                                    enemy.direction = targetDirection;
                                    enemy.preferredDirection = targetDirection;
                                    enemy.directionStability = 0;
                                }
                            } else {
                                enemy.directionStability = 0;
                            }
                        }
                    }
                    
                    // AIå°„å‡»
                    if (now - enemy.lastShot > enemy.shotCooldown) {
                        this.enemyShoot(enemy);
                    }
                });
            }
            
            updateBullets() {
                this.bullets = this.bullets.filter(bullet => {
                    // ç§»åŠ¨å­å¼¹
                    switch (bullet.direction) {
                        case 0: bullet.y -= bullet.speed; break;
                        case 1: bullet.x += bullet.speed; break;
                        case 2: bullet.y += bullet.speed; break;
                        case 3: bullet.x -= bullet.speed; break;
                    }
                    
                    // æ£€æŸ¥è¾¹ç•Œ
                    if (bullet.x < 0 || bullet.x > this.canvas.width ||
                        bullet.y < 0 || bullet.y > this.canvas.height) {
                        return false;
                    }
                    
                    // å…ˆæ£€æŸ¥åŸºåœ°å¢™å£ç¢°æ’ï¼ˆä¼˜å…ˆå¤„ç†ï¼‰
                    if (this.checkBaseWallCollision(bullet)) {
                        return false; // çˆ†ç‚¸æ•ˆæœåœ¨checkBaseWallCollisionä¸­å¤„ç†
                    }
                    
                    // æ£€æŸ¥æ™®é€šå¢™å£ç¢°æ’
                    if (this.checkNormalWallCollision(bullet.x, bullet.y, bullet.width, bullet.height)) {
                        this.createExplosion(bullet.x + bullet.width/2, bullet.y + bullet.height/2);
                        return false;
                    }
                    
                    return true;
                });
            }
            
            updateExplosions() {
                this.explosions = this.explosions.filter(explosion => {
                    explosion.age++;
                    explosion.radius += explosion.expandSpeed;
                    explosion.opacity -= explosion.fadeSpeed;
                    
                    return explosion.age < explosion.maxAge && explosion.opacity > 0;
                });
            }
            
            createExplosion(x, y, size = 'normal') {
                const explosion = {
                    x: x,
                    y: y,
                    radius: size === 'large' ? 5 : 3,
                    maxRadius: size === 'large' ? 30 : 20,
                    expandSpeed: size === 'large' ? 2 : 1.5,
                    opacity: 1,
                    fadeSpeed: size === 'large' ? 0.05 : 0.08,
                    age: 0,
                    maxAge: size === 'large' ? 20 : 15,
                    color: size === 'large' ? '#ff6b35' : '#fbbf24'
                };
                this.explosions.push(explosion);
            }
            
            playerShoot() {
                const player = this.player;
                const bullet = {
                    x: player.x + player.width / 2 - 2,
                    y: player.y + player.height / 2 - 2,
                    width: 4,
                    height: 4,
                    direction: player.direction,
                    speed: 8,
                    owner: 'player'
                };
                
                this.bullets.push(bullet);
                player.lastShot = Date.now();
            }
            
            enemyShoot(enemy) {
                const bullet = {
                    x: enemy.x + enemy.width / 2 - 2,
                    y: enemy.y + enemy.height / 2 - 2,
                    width: 4,
                    height: 4,
                    direction: enemy.direction,
                    speed: 6,
                    owner: 'enemy'
                };
                
                this.bullets.push(bullet);
                enemy.lastShot = Date.now();
            }
            
            checkNormalWallCollision(x, y, width, height) {
                return this.walls.some(wall => 
                    x < wall.x + wall.width &&
                    x + width > wall.x &&
                    y < wall.y + wall.height &&
                    y + height > wall.y
                );
            }
            
            checkWallCollision(x, y, width, height) {
                return this.checkNormalWallCollision(x, y, width, height) || this.baseWalls.some(wall => {
                    // åªæœ‰å¥åº·çš„å¢™ä½“æ‰ä¼šå‘ç”Ÿç¢°æ’
                    return wall.health > 0 &&
                           x < wall.x + wall.width &&
                           x + width > wall.x &&
                           y < wall.y + wall.height &&
                           y + height > wall.y;
                });
            }
            
            checkTankCollision(tank, newX, newY) {
                // æ£€æŸ¥ä¸ç©å®¶å¦å…‹ç¢°æ’
                if (tank !== this.player &&
                    newX < this.player.x + this.player.width &&
                    newX + tank.width > this.player.x &&
                    newY < this.player.y + this.player.height &&
                    newY + tank.height > this.player.y) {
                    return true;
                }
                
                // æ£€æŸ¥ä¸å…¶ä»–æ•Œæ–¹å¦å…‹ç¢°æ’
                return this.enemies.some(enemy => {
                    if (enemy === tank) return false;
                    return newX < enemy.x + enemy.width &&
                           newX + tank.width > enemy.x &&
                           newY < enemy.y + enemy.height &&
                           newY + tank.height > enemy.y;
                });
            }
            
            checkBaseWallCollision(bullet) {
                for (let i = 0; i < this.baseWalls.length; i++) {
                    const wall = this.baseWalls[i];
                    if (bullet.x < wall.x + wall.width &&
                        bullet.x + bullet.width > wall.x &&
                        bullet.y < wall.y + wall.height &&
                        bullet.y + bullet.height > wall.y) {
                        
                        // å¦‚æœå¢™ä½“å·²ç»è¢«æ‘§æ¯ï¼Œç›´æ¥ä¼¤å®³åŸºåœ°
                        if (wall.health <= 0) {
                            this.base.health -= 10;
                            this.createExplosion(bullet.x + bullet.width/2, bullet.y + bullet.height/2);
                            return true;
                        }
                        
                        // å¢™ä½“è¢«å‡»ä¸­åç›´æ¥æ‘§æ¯æ•´ä¸ªæ ¼å­
                        wall.health = 0;
                        this.createExplosion(bullet.x + bullet.width/2, bullet.y + bullet.height/2);
                        
                        return true;
                    }
                }
                return false;
            }
            
            checkCollisions() {
                // å­å¼¹ä¸å¦å…‹ç¢°æ’
                this.bullets.forEach((bullet, bulletIndex) => {
                    // å­å¼¹ä¸ç©å®¶ç¢°æ’
                    if (bullet.owner === 'enemy' &&
                        bullet.x < this.player.x + this.player.width &&
                        bullet.x + bullet.width > this.player.x &&
                        bullet.y < this.player.y + this.player.height &&
                        bullet.y + bullet.height > this.player.y) {
                        
                        this.createExplosion(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 'large');
                        this.bullets.splice(bulletIndex, 1);
                        this.player.health -= 25;
                        
                        if (this.player.health <= 0) {
                            this.lives--;
                            this.player.health = this.player.maxHealth;
                            this.player.x = 100;
                            this.player.y = 500;
                            this.updateDisplay();
                        }
                    }
                    
                    // å­å¼¹ä¸æ•Œæ–¹å¦å…‹ç¢°æ’
                    if (bullet.owner === 'player') {
                        this.enemies.forEach((enemy, enemyIndex) => {
                            if (bullet.x < enemy.x + enemy.width &&
                                bullet.x + bullet.width > enemy.x &&
                                bullet.y < enemy.y + enemy.height &&
                                bullet.y + bullet.height > enemy.y) {
                                
                                this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 'large');
                                this.bullets.splice(bulletIndex, 1);
                                this.enemies.splice(enemyIndex, 1);
                                this.score += 100;
                                this.updateDisplay();
                            }
                        });
                    }
                    
                    // å­å¼¹ä¸åŸºåœ°ç¢°æ’ï¼ˆäº”è§’æ˜ŸåŒºåŸŸæ£€æµ‹ï¼‰
                    if (bullet.owner === 'enemy' && this.checkStarCollision(bullet)) {
                        this.createExplosion(bullet.x + bullet.width/2, bullet.y + bullet.height/2, 'large');
                        this.bullets.splice(bulletIndex, 1);
                        this.base.health -= 50;
                        
                        if (this.base.health <= 0) {
                            this.createExplosion(this.base.x + this.base.width/2, this.base.y + this.base.height/2, 'large');
                            this.gameOver('åŸºåœ°è¢«æ‘§æ¯ï¼');
                        }
                    }
                });
            }
            
            checkGameEnd() {
                if (this.lives <= 0) {
                    this.gameOver('ç”Ÿå‘½å€¼è€—å°½ï¼');
                } else if (this.base.health <= 0) {
                    this.gameOver('åŸºåœ°è¢«æ‘§æ¯ï¼');
                } else if (this.enemies.length === 0) {
                    this.levelComplete();
                }
            }
            
            levelComplete() {
                this.level++;
                this.enemyCount = Math.min(8, 5 + this.level);
                this.initGame();
                this.updateDisplay();
            }
            
            gameOver(reason = 'æ¸¸æˆç»“æŸ') {
                this.pause();
                alert(`${reason}\næœ€ç»ˆå¾—åˆ†: ${this.score}\nåˆ°è¾¾å…³å¡: ${this.level}`);
            }
            
            draw() {
                // æ¸…ç©ºç”»å¸ƒ
                this.ctx.fillStyle = '#0f172a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ç»˜åˆ¶å¢™å£
                this.ctx.fillStyle = '#8b5cf6';
                this.walls.forEach(wall => {
                    this.ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                });
                
                // ç»˜åˆ¶åŸºåœ°ï¼ˆäº”è§’æ˜Ÿï¼‰
                this.drawStar(this.base.x + this.base.width/2, this.base.y + this.base.height/2, 5, 25, 15, '#fbbf24');
                
                // åŸºåœ°å¤´é¡¶è¡€æ¡å·²ç§»é™¤ï¼Œç°åœ¨ä½¿ç”¨ä¾§è¾¹æ è¡€æ¡æ˜¾ç¤º
                
                // ç»˜åˆ¶åŸºåœ°é˜²æŠ¤å¢™ï¼ˆåªç»˜åˆ¶å¥åº·çš„å¢™ä½“ï¼‰
                this.baseWalls.forEach(wall => {
                    if (wall.health > 0) {
                        // ç»˜åˆ¶å®Œæ•´çš„å¢™ä½“
                        this.ctx.fillStyle = '#8B4513';
                        this.ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                        
                        // å¢™ä½“è¾¹æ¡†
                        this.ctx.strokeStyle = '#654321';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
                    }
                });
                
                // ç»˜åˆ¶ç©å®¶å¦å…‹
                this.drawTank(this.player, '#10b981');
                
                // ç»˜åˆ¶æ•Œæ–¹å¦å…‹
                this.enemies.forEach(enemy => {
                    this.drawTank(enemy, '#ef4444');
                });
                
                // ç»˜åˆ¶å­å¼¹
                this.bullets.forEach(bullet => {
                    this.ctx.fillStyle = bullet.owner === 'player' ? '#fbbf24' : '#f87171';
                    this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                });
                
                // ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
                this.explosions.forEach(explosion => {
                    this.ctx.save();
                    this.ctx.globalAlpha = explosion.opacity;
                    
                    // å¤–åœˆç«ç„°æ•ˆæœ
                    const gradient = this.ctx.createRadialGradient(
                        explosion.x, explosion.y, 0,
                        explosion.x, explosion.y, explosion.radius
                    );
                    gradient.addColorStop(0, explosion.color);
                    gradient.addColorStop(0.5, '#ff8c42');
                    gradient.addColorStop(1, 'rgba(255, 140, 66, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // å†…åœˆäº®å…‰æ•ˆæœ
                    if (explosion.age < explosion.maxAge / 2) {
                        const innerGradient = this.ctx.createRadialGradient(
                            explosion.x, explosion.y, 0,
                            explosion.x, explosion.y, explosion.radius * 0.6
                        );
                        innerGradient.addColorStop(0, '#ffffff');
                        innerGradient.addColorStop(0.3, explosion.color);
                        innerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        this.ctx.fillStyle = innerGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(explosion.x, explosion.y, explosion.radius * 0.6, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
                
                // ç©å®¶å¤´é¡¶è¡€æ¡å·²ç§»é™¤ï¼Œç°åœ¨ä½¿ç”¨ä¾§è¾¹æ è¡€æ¡æ˜¾ç¤º
            }
            
            drawTank(tank, color) {
                this.ctx.save();
                this.ctx.translate(tank.x + tank.width / 2, tank.y + tank.height / 2);
                this.ctx.rotate(tank.direction * Math.PI / 2);
                
                // å¦å…‹ä¸»ä½“
                this.ctx.fillStyle = color;
                this.ctx.fillRect(-tank.width / 2, -tank.height / 2, tank.width, tank.height);
                
                // å¦å…‹ç‚®ç®¡
                this.ctx.fillStyle = '#374151';
                this.ctx.fillRect(-2, -tank.height / 2 - 15, 4, 15);
                
                this.ctx.restore();
            }
            
            drawStar(cx, cy, spikes, outerRadius, innerRadius, color) {
                this.ctx.save();
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / spikes;
                
                this.ctx.moveTo(cx, cy - outerRadius);
                
                for (let i = 0; i < spikes; i++) {
                    x = cx + Math.cos(rot) * outerRadius;
                    y = cy + Math.sin(rot) * outerRadius;
                    this.ctx.lineTo(x, y);
                    rot += step;
                    
                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    this.ctx.lineTo(x, y);
                    rot += step;
                }
                
                this.ctx.lineTo(cx, cy - outerRadius);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.restore();
            }
            
            checkStarCollision(bullet) {
                const cx = this.base.x + this.base.width / 2;
                const cy = this.base.y + this.base.height / 2;
                const bulletCenterX = bullet.x + bullet.width / 2;
                const bulletCenterY = bullet.y + bullet.height / 2;
                
                // ç®€åŒ–çš„åœ†å½¢ç¢°æ’æ£€æµ‹ï¼ˆäº”è§’æ˜Ÿå¤–æ¥åœ†ï¼‰
                const distance = Math.sqrt(
                    Math.pow(bulletCenterX - cx, 2) + Math.pow(bulletCenterY - cy, 2)
                );
                
                return distance <= 25; // äº”è§’æ˜Ÿå¤–åŠå¾„
            }
            
            updateDisplay() {
                document.getElementById('lives').textContent = this.player.lives;
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('enemies').textContent = this.enemies.length;
                
                // æ›´æ–°è¡€æ¡æ˜¾ç¤º
                const playerHealthPercent = (this.player.health / this.player.maxHealth) * 100;
                const baseHealthPercent = (this.base.health / this.base.maxHealth) * 100;
                
                document.getElementById('playerHealthText').textContent = `${this.player.health}/${this.player.maxHealth}`;
                document.getElementById('baseHealthText').textContent = `${this.base.health}/${this.base.maxHealth}`;
                
                document.getElementById('playerHealthBar').style.width = `${playerHealthPercent}%`;
                document.getElementById('baseHealthBar').style.width = `${baseHealthPercent}%`;
                
                // æ ¹æ®è¡€é‡æ”¹å˜è¡€æ¡é¢œè‰²
                const playerBar = document.getElementById('playerHealthBar');
                const baseBar = document.getElementById('baseHealthBar');
                
                if (playerHealthPercent > 60) {
                    playerBar.className = 'bg-green-500 h-3 rounded-full transition-all duration-300';
                } else if (playerHealthPercent > 30) {
                    playerBar.className = 'bg-yellow-500 h-3 rounded-full transition-all duration-300';
                } else {
                    playerBar.className = 'bg-red-500 h-3 rounded-full transition-all duration-300';
                }
                
                if (baseHealthPercent > 60) {
                    baseBar.className = 'bg-yellow-500 h-3 rounded-full transition-all duration-300';
                } else if (baseHealthPercent > 30) {
                    baseBar.className = 'bg-orange-500 h-3 rounded-full transition-all duration-300';
                } else {
                    baseBar.className = 'bg-red-500 h-3 rounded-full transition-all duration-300';
                }
            }
            
            start() {
                if (!this.gameRunning) {
                    this.gameRunning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('pauseBtn').disabled = false;
                    this.gameLoop = setInterval(() => {
                        this.update();
                        this.draw();
                    }, 1000 / 60);
                }
            }
            
            pause() {
                if (this.gameRunning) {
                    this.gameRunning = false;
                    clearInterval(this.gameLoop);
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('pauseBtn').disabled = true;
                }
            }
            
            reset() {
                this.pause();
                this.lives = 3;
                this.score = 0;
                this.level = 1;
                this.enemyCount = 5;
                this.base.health = this.base.maxHealth;
                // é‡ç½®åŸºåœ°é˜²æŠ¤å¢™çš„ç¼ºå£çŠ¶æ€
                this.baseWalls.forEach(wall => {
                    wall.health = wall.maxHealth;
                    wall.holes = []; // æ¸…é™¤æ‰€æœ‰ç¼ºå£
                });
                this.initGame();
                this.draw();
            }
            
            bindEvents() {
                // é”®ç›˜äº‹ä»¶
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key === 'p' || e.key === 'P') {
                        if (this.gameRunning) {
                            this.pause();
                        } else {
                            this.start();
                        }
                    }
                    e.preventDefault();
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
                
                // æŒ‰é’®äº‹ä»¶
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                
                // ç§»åŠ¨ç«¯æ§åˆ¶
                document.getElementById('upBtn').addEventListener('click', () => {
                    this.keys['w'] = true;
                    setTimeout(() => this.keys['w'] = false, 100);
                });
                document.getElementById('downBtn').addEventListener('click', () => {
                    this.keys['s'] = true;
                    setTimeout(() => this.keys['s'] = false, 100);
                });
                document.getElementById('leftBtn').addEventListener('click', () => {
                    this.keys['a'] = true;
                    setTimeout(() => this.keys['a'] = false, 100);
                });
                document.getElementById('rightBtn').addEventListener('click', () => {
                    this.keys['d'] = true;
                    setTimeout(() => this.keys['d'] = false, 100);
                });
                document.getElementById('fireBtn').addEventListener('click', () => {
                    this.keys['k'] = true;
                    setTimeout(() => this.keys['k'] = false, 100);
                });
            }
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        const game = new TankBattle();
        game.draw();
    </script>
</body>
</html>